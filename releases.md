# Заметки релиза

- [Схема Версионирования](#versioning-scheme)
- [Политика поддержки](#support-policy)
- [Laravel 6](#laravel-6)

<a name="versioning-scheme"></a>
## Схема Версионирования

Laravel и другие сторонние пакеты следуют схемы вресионирования [Semantic Versioning](https://semver.org). Основные выпуски фреймворка выпускаются каждые шесть месяцев (февраль и август), в то время как небольшие выпуски и патчи могут выпускаться так же часто, как и каждую неделю. Незначительные и патч-релизы никогда не должны содержать критических изменений.

При обращении к платформе Laravel или ее компонентам из вашего приложения или пакета вы всегда должны use ограничение версии, такое как ^ 6.0, поскольку основные выпуски Laravel действительно содержат критические изменения. Однако мы всегда стремимся к тому, чтобы вы могли обновиться до новой основной версии за один день или меньше.

<a name="support-policy"></a>
## Политика поддержки

Для выпусков LTS ( англ. Long-Term Support; дословно "поддержка в течение длительного периода" ), таких как Laravel 6, исправления ошибок предоставляются в течение 2 лет, а исправления безопасности - в течение 3 лет. Эти выпуски предоставляют самое длинное окно поддержки и обслуживания. Для общих выпусков исправления ошибок предоставляются в течение 6 месяцев, а исправления безопасности - в течение 1 года. Для всех дополнительных библиотек, включая Lumen, только последний выпуск получает исправления ошибок. Кроме того, пожалуйста, просмотрите версии [базы данных](/docs/{{version}}/database#introduction).

| Версия | Релиз | Исправления багов до | Исправления безопасности до |
| --- | --- | --- | --- |
| 5,5 (LTS) | 30 августа 2017 года | 30 августа 2019 года | 30 августа 2020 года |
| 5.6 | 7 февраля 2018 | 7 августа 2018 года | 7 февраля 2019 |
| 5.7 | 4 сентября 2018 года | 4 марта 2019 года | 4 сентября 2019 года |
| 5.8 | 26 февраля 2019 | 26 августа 2019 | 26 февраля 2020 |
| 6 (LTS) | 3 сентября 2019 | 3 сентября 2021 года | 3 сентября 2022 года |

<a name="laravel-6"></a>
## Laravel 6

Laravel 6 (LTS) продолжает усовершенствования, внесенные в Laravel 5.8, путем введения семантического управления версиями, совместимости с [Laravel Vapor](https://vapor.laravel.com), улучшенных ответов авторизации, промежуточного программного обеспечения, ленивых коллекций, улучшений подзапросов, извлечения каркасов внешнего интерфейса в `laravel/ui` Composer, а также множество других исправлений ошибок и улучшений юзабилити.

### Семантическое управление версиями

Пакет Laravel Framework (`laravel/framework`) теперь соответствует стандарту [семантическое управление версиями](https://semver.org/). Это делает платформу совместимой с другими первыми пакетами Laravel, которые уже следовали этому стандарту версий. Цикл выпуска Laravel останется неизменным.

### Совместимость с Vapor Laravel

_Laravel Vapor был построен [Тейлор Отвелл](https://github.com/taylorotwell)_.
Laravel 6 обеспечивает совместимость с [Laravel Vapor](https://vapor.laravel.com), автоматически масштабируемой платформой для развертывания без сервера для Laravel. Vapor демонстрирует сложность управления приложениями Laravel в AWS Lambda, а также сопряжения этих приложений с очередями SQS, базами данных, кластерами Redis, сетями, CloudFront CDN и многим другим.

### Улучшенные исключения через зажигание

Laravel 6 поставляется с [Ignition](https://github.com/facade/ignition), новой страницей подробностей исключений с открытым исходным кодом, созданной Freek Van der Herten и Marcel Pociot. Ignition предлагает много преимуществ по сравнению с предыдущими выпусками, таких как улучшенная обработка файла ошибок Blade и номера строки, выполнимые решения для общих проблем, редактирование кода, совместное использование исключений и улучшенный UX.

### Улучшенные ответы авторизации

_Улучшенные ответы на авторизацию были реализованы [Гари Грин](https://github.com/garygreen)_.
В предыдущих выпусках Laravel было сложно получать и предоставлять пользовательские сообщения авторизации конечным пользователям. Это затрудняло объяснение конечным пользователям, почему конкретный запрос был отклонен. В Laravel 6 это теперь намного проще, используя ответные сообщения авторизации и новый метод `Gate::inspect`. Например, учитывая следующий метод политики:

    /**
     * Определите, может ли пользователь просматривать данный рейс.
     *
     * @param  \App\User  $user
     * @param  \App\Flight  $flight
     * @return mixed
     */
    public function view(User $user, Flight $flight)
    {
        return $this->deny('Explanation of denial.');
    }

Ответ и сообщение политики авторизации могут быть легко получены с помощью метода `Gate::inspect`:

    $response = Gate::inspect('view', $flight);

    if ($response->allowed()) {
        // User is authorized to view the flight...
    }

    if ($response->denied()) {
        echo $response->message();
    }

Кроме того, эти пользовательские сообщения будут автоматически возвращаться на ваш веб-интерфейс при использовании вспомогательных методов, таких как `$this->authorize` или`Gate::authorize`, из ваших маршрутов или контроллеров.

### Job Middleware

_Job middleware were implemented by [Taylor Otwell](https://github.com/taylorotwell)_.

Job middleware allow you to wrap custom logic around the execution of queued jobs, reducing boilerplate in the jobs themselves. For example, in previous releases of Laravel, you may have wrapped the logic of a job's `handle` method within a rate-limited callback:

### Промежуточное программное обеспечение выполнения задач, работ

_Промежуточное программное обеспечение выполнения задач, работ было реализовано [Taylor Otwell](https://github.com/taylorotwell)_.

Промежуточное программное обеспечение работ позволяет вам обернуть пользовательскую логику в выполнение заданий, поставленных в очередь, что сокращает количество стандартных заданий. Например, в предыдущих выпусках Laravel вы могли обернуть логику метода handle для задания в обратный вызов с ограниченной скоростью:

    /**
     * Выполнить работу.
     *
     * @return void
     */
    public function handle()
    {
        Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function () {
            info('Lock obtained...');

            // Handle job...
        }, function () {
            // Could not obtain lock...

            return $this->release(5);
        });
    }

В Laravel 6 эта логика может быть извлечена в промежуточное программное обеспечение для работы, позволяя вам освободить метод "обработки" вашей работы от любых обязанностей, ограничивающих скорость:

    <?php

    namespace App\Jobs\Middleware;

    use Illuminate\Support\Facades\Redis;

    class RateLimited
    {
        /**
         * Обработать работу в очереди.
         *
         * @param  mixed  $job
         * @param  callable  $next
         * @return mixed
         */
        public function handle($job, $next)
        {
            Redis::throttle('key')
                    ->block(0)->allow(1)->every(5)
                    ->then(function () use ($job, $next) {
                        // Lock obtained...

                        $next($job);
                    }, function () use ($job) {
                        // Could not obtain lock...

                        $job->release(5);
                    });
        }
    }

После создания промежуточного программного обеспечения их можно прикрепить к заданию, вернув их из метода `middleware` задания:

    use App\Jobs\Middleware\RateLimited;

    /**
     * Get the middleware the job should pass through.
     *
     * @return array
     */
    public function middleware()
    {
        return [new RateLimited];
    }


### Ленивые Коллекции

_Ленивые коллекции были реализованы [Джозефом Силбером](https://github.com/JosephSilber)_.

Многим разработчикам уже нравятся мощные [методы сбора] Laravel (https://laravel.com/docs/collections). В дополнение к уже мощному классу `Collection`, Laravel 6 представляет `LazyCollection`, который использует PHP [generators](https://www.php.net/manual/en/language.generators.overview.php), чтобы позволить вам работать с очень большими наборами данных при сохранении низкого использования памяти.

Например, представьте, что вашему приложению требуется обработать файл журнала размером в несколько гигабайт, используя преимущества методов сбора данных Laravel для анализа журналов. Вместо одновременного чтения всего файла в память, ленивые коллекции могут использоваться для хранения только небольшой части файла в памяти в данный момент времени:

    use App\LogEntry;
    use Illuminate\Support\LazyCollection;

    LazyCollection::make(function () {
        $handle = fopen('log.txt', 'r');

        while (($line = fgets($handle)) !== false) {
            yield $line;
        }
    })
    ->chunk(4)
    ->map(function ($lines) {
        return LogEntry::fromLines($lines);
    })
    ->each(function (LogEntry $logEntry) {
        // Process the log entry...
    });

Или представьте, что вам нужно перебрать 10 000 моделей Eloquent. При использовании традиционных коллекций Laravel все 10 000 моделей Eloquent должны быть загружены в память одновременно:

    $users = App\User::all()->filter(function ($user) {
        return $user->id > 500;
    });

Однако, начиная с Laravel 6, метод курсора строителя запросов был обновлен, чтобы возвращать экземпляр `LazyCollection`. Это позволяет вам по-прежнему выполнять только один запрос к базе данных, но одновременно сохранять в памяти только одну модель Eloquent. В этом примере обратный вызов `filter` не выполняется до тех пор, пока мы фактически не проведем итерацию по каждому пользователю индивидуально, что позволяет значительно сократить использование памяти:

    $users = App\User::cursor()->filter(function ($user) {
        return $user->id > 500;
    });

    foreach ($users as $user) {
        echo $user->id;
    }

### Расширения Eloquent Subquery

_Прекрасные усовершенствования подзапроса были реализованы [Jonathan Reinink](https://github.com/reinink)_.

Laravel 6 представляет несколько новых улучшений и улучшений поддержки подзапросов к базам данных.
Например, давайте представим, что у нас есть таблица пунктов назначения рейсов `destinations` и таблица пунктов назначения `flights`.
В таблице `flights` содержится столбец `Arrive_at`, который указывает, когда рейс прибыл в пункт назначения.

Используя новую функцию выбора подзапроса в Laravel 6, мы можем выбрать все пункты назначения и название рейса, который последний раз прибыл в этот пункт назначения, используя один запрос:

    return Destination::addSelect(['last_flight' => Flight::select('name')
        ->whereColumn('destination_id', 'destinations.id')
        ->orderBy('arrived_at', 'desc')
        ->limit(1)
    ])->get();

Кроме того, мы можем использовать новые функции подзапросов, добавленные в функцию orderBy строителя запросов, чтобы отсортировать все пункты назначения в зависимости от того, когда последний рейс прибыл в этот пункт назначения. Опять же, это может быть сделано при выполнении одного запроса к базе данных:

    return Destination::orderByDesc(
        Flight::select('arrived_at')
            ->whereColumn('destination_id', 'destinations.id')
            ->orderBy('arrived_at', 'desc')
            ->limit(1)
    )->get();


### Laravel UI

Геннерация Frontend-а (Виды, контролеры, маршруты), обычно предоставляемые в предыдущих выпусках Laravel, были извлечены в пакет Composer `laravel/ui`. Это позволяет создавать собственные пользовательские интерфейсы и создавать версии отдельно от основной среды. В результате этого изменения в базовом каркасе фреймворка по умолчанию отсутствует код Bootstrap или Vue, а также была извлечена команда `make:auth` из фреймворка.

Чтобы восстановить традиционные леса Vue/Bootstrap, которые присутствовали в предыдущих выпусках Laravel, вы можете установить пакет `laravel/ui` и use команду`ui` Artisan для установки лесов внешнего интерфейса:

    composer require laravel/ui --dev

    php artisan ui vue --auth

